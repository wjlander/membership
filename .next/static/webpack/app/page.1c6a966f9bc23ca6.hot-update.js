"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/pocketbase.ts":
/*!*******************************!*\
  !*** ./src/lib/pocketbase.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthService: () => (/* binding */ AuthService),\n/* harmony export */   TenantService: () => (/* binding */ TenantService),\n/* harmony export */   createMailingList: () => (/* binding */ createMailingList),\n/* harmony export */   createMembership: () => (/* binding */ createMembership),\n/* harmony export */   createMembershipType: () => (/* binding */ createMembershipType),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getDashboardStats: () => (/* binding */ getDashboardStats),\n/* harmony export */   getMailingLists: () => (/* binding */ getMailingLists),\n/* harmony export */   getMembershipTypes: () => (/* binding */ getMembershipTypes),\n/* harmony export */   getMemberships: () => (/* binding */ getMemberships),\n/* harmony export */   getOrganization: () => (/* binding */ getOrganization),\n/* harmony export */   getOrganizationBySubdomain: () => (/* binding */ getOrganizationBySubdomain),\n/* harmony export */   getUserSubscriptions: () => (/* binding */ getUserSubscriptions),\n/* harmony export */   getUsers: () => (/* binding */ getUsers),\n/* harmony export */   pb: () => (/* binding */ pb),\n/* harmony export */   updateMembership: () => (/* binding */ updateMembership),\n/* harmony export */   updateMembershipType: () => (/* binding */ updateMembershipType),\n/* harmony export */   updateSubscription: () => (/* binding */ updateSubscription),\n/* harmony export */   updateUserStatus: () => (/* binding */ updateUserStatus)\n/* harmony export */ });\n/* harmony import */ var pocketbase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pocketbase */ \"(app-pages-browser)/./node_modules/pocketbase/dist/pocketbase.es.mjs\");\n\n// PocketBase client singleton\nclass PocketBaseClient {\n    static getInstance() {\n        if (!PocketBaseClient.instance) {\n            const url = \"https://p.ringing.org.uk\" || 0;\n            PocketBaseClient.instance = new pocketbase__WEBPACK_IMPORTED_MODULE_0__[\"default\"](url);\n        }\n        return PocketBaseClient.instance;\n    }\n}\nconst pb = PocketBaseClient.getInstance();\n// Helper functions for multi-tenant operations\nclass TenantService {\n    static async getOrganizationBySubdomain(subdomain) {\n        try {\n            const record = await pb.collection('organizations').getFirstListItem('subdomain = \"'.concat(subdomain, '\" && status = \"active\"'));\n            return record;\n        } catch (error) {\n            console.warn(\"Organization '\".concat(subdomain, \"' not found or PocketBase not accessible:\"), error);\n            return null;\n        }\n    }\n    static async getCurrentTenant() {\n        if (false) {}\n        const hostname = window.location.hostname;\n        const subdomain = hostname.split('.')[0];\n        // For development, check if subdomain is in the URL path or query\n        if (hostname === 'localhost' || hostname.includes('127.0.0.1')) {\n            const urlParams = new URLSearchParams(window.location.search);\n            const tenantParam = urlParams.get('tenant');\n            if (tenantParam) {\n                return this.getOrganizationBySubdomain(tenantParam);\n            }\n            // Try to get default organization for development\n            // Try to get default organization for development\n            try {\n                const records = await pb.collection('organizations').getList(1, 1, {\n                    filter: 'status = \"active\"'\n                });\n                if (records.items.length > 0) {\n                    return records.items[0];\n                }\n                // If no organizations exist, return a development fallback\n                console.warn('No organizations found in database. Using development fallback.');\n                return {\n                    id: 'dev-org',\n                    name: 'Development Organization',\n                    subdomain: 'dev-org',\n                    status: 'active',\n                    created: new Date().toISOString(),\n                    updated: new Date().toISOString()\n                };\n            } catch (error) {\n                console.warn('PocketBase not accessible. Using development fallback organization.');\n                return {\n                    id: 'dev-org',\n                    name: 'Development Organization',\n                    subdomain: 'dev-org',\n                    status: 'active',\n                    created: new Date().toISOString(),\n                    updated: new Date().toISOString()\n                };\n            }\n        }\n        return this.getOrganizationBySubdomain(subdomain);\n    }\n    static setTenantContext(tenantId) {\n        // Set tenant context for subsequent requests\n        pb.beforeSend = function(url, options) {\n            options.headers = {\n                ...options.headers,\n                'X-Tenant-ID': tenantId\n            };\n            return {\n                url,\n                options\n            };\n        };\n    }\n}\n// Authentication helpers\nclass AuthService {\n    static async login(email, password, tenantId) {\n        try {\n            TenantService.setTenantContext(tenantId);\n            const authData = await pb.collection('users').authWithPassword(email, password);\n            // Verify user belongs to the correct tenant\n            if (authData.record.tenant_id !== tenantId) {\n                await pb.authStore.clear();\n                throw new Error('Invalid credentials for this organization');\n            }\n            return authData;\n        } catch (error) {\n            console.error('Login error:', error);\n            throw error;\n        }\n    }\n    static async register(userData) {\n        try {\n            TenantService.setTenantContext(userData.tenant_id);\n            const record = await pb.collection('users').create({\n                ...userData,\n                role: 'member',\n                status: 'pending'\n            });\n            return record;\n        } catch (error) {\n            console.error('Registration error:', error);\n            throw error;\n        }\n    }\n    static logout() {\n        pb.authStore.clear();\n    }\n    static getCurrentUser() {\n        return pb.authStore.model;\n    }\n    static isAuthenticated() {\n        return pb.authStore.isValid;\n    }\n}\nconst getCurrentTenantId = ()=>{\n    var _pb_authStore_model;\n    return ((_pb_authStore_model = pb.authStore.model) === null || _pb_authStore_model === void 0 ? void 0 : _pb_authStore_model.tenant_id) || null;\n};\n// Organization methods\nconst getOrganization = async (id)=>{\n    try {\n        return await pb.collection('organizations').getOne(id);\n    } catch (error) {\n        console.error('Error fetching organization:', error);\n        return null;\n    }\n};\nconst getOrganizationBySubdomain = async (subdomain)=>{\n    try {\n        const records = await pb.collection('organizations').getList(1, 1, {\n            filter: 'subdomain = \"'.concat(subdomain, '\"')\n        });\n        return records.items[0] || null;\n    } catch (error) {\n        console.error('Error fetching organization by subdomain:', error);\n        return null;\n    }\n};\n// User methods\nconst getUsers = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, perPage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50, filter = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '';\n    return await pb.collection('users').getList(page, perPage, {\n        filter: filter ? 'name ~ \"'.concat(filter, '\" || email ~ \"').concat(filter, '\"') : '',\n        sort: '-created',\n        expand: 'tenant_id'\n    });\n};\nconst updateUserStatus = async (userId, status)=>{\n    return await pb.collection('users').update(userId, {\n        status\n    });\n};\n// Membership Type methods\nconst getMembershipTypes = async ()=>{\n    return await pb.collection('membership_types').getFullList({\n        filter: 'active = true',\n        sort: 'price'\n    });\n};\nconst createMembershipType = async (data)=>{\n    return await pb.collection('membership_types').create({\n        ...data,\n        tenant_id: getCurrentTenantId()\n    });\n};\nconst updateMembershipType = async (id, data)=>{\n    return await pb.collection('membership_types').update(id, data);\n};\n// Membership methods\nconst getMemberships = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, perPage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50, filter = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '';\n    return await pb.collection('memberships').getList(page, perPage, {\n        filter,\n        sort: '-created',\n        expand: 'user_id,membership_type_id'\n    });\n};\nconst createMembership = async (data)=>{\n    return await pb.collection('memberships').create({\n        ...data,\n        tenant_id: getCurrentTenantId()\n    });\n};\nconst updateMembership = async (id, data)=>{\n    return await pb.collection('memberships').update(id, data);\n};\n// Mailing List methods\nconst getMailingLists = async ()=>{\n    return await pb.collection('mailing_lists').getFullList({\n        filter: 'active = true',\n        sort: 'name'\n    });\n};\nconst createMailingList = async (data)=>{\n    return await pb.collection('mailing_lists').create({\n        ...data,\n        tenant_id: getCurrentTenantId()\n    });\n};\n// List Subscription methods\nconst getUserSubscriptions = async (userId)=>{\n    return await pb.collection('list_subscriptions').getFullList({\n        filter: 'user_id = \"'.concat(userId, '\"'),\n        expand: 'list_id'\n    });\n};\nconst updateSubscription = async (userId, listId, subscribed)=>{\n    try {\n        // Try to find existing subscription\n        const existing = await pb.collection('list_subscriptions').getFirstListItem('user_id = \"'.concat(userId, '\" && list_id = \"').concat(listId, '\"'));\n        return await pb.collection('list_subscriptions').update(existing.id, {\n            subscribed\n        });\n    } catch (error) {\n        // Create new subscription if it doesn't exist\n        return await pb.collection('list_subscriptions').create({\n            tenant_id: getCurrentTenantId(),\n            user_id: userId,\n            list_id: listId,\n            subscribed\n        });\n    }\n};\n// Dashboard stats\nconst getDashboardStats = async ()=>{\n    const tenantId = getCurrentTenantId();\n    if (!tenantId) throw new Error('No tenant context');\n    const [users, memberships] = await Promise.all([\n        pb.collection('users').getList(1, 1, {\n            filter: 'tenant_id = \"'.concat(tenantId, '\"')\n        }),\n        pb.collection('memberships').getList(1, 1, {\n            filter: 'tenant_id = \"'.concat(tenantId, '\"')\n        })\n    ]);\n    const activeUsers = await pb.collection('users').getList(1, 1, {\n        filter: 'tenant_id = \"'.concat(tenantId, '\" && status = \"active\"')\n    });\n    const pendingUsers = await pb.collection('users').getList(1, 1, {\n        filter: 'tenant_id = \"'.concat(tenantId, '\" && status = \"pending\"')\n    });\n    const activeMemberships = await pb.collection('memberships').getList(1, 1, {\n        filter: 'tenant_id = \"'.concat(tenantId, '\" && status = \"active\"')\n    });\n    // Calculate expiring memberships (next 30 days)\n    const thirtyDaysFromNow = new Date();\n    thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);\n    const expiringMemberships = await pb.collection('memberships').getList(1, 1, {\n        filter: 'tenant_id = \"'.concat(tenantId, '\" && status = \"active\" && end_date <= \"').concat(thirtyDaysFromNow.toISOString().split('T')[0], '\"')\n    });\n    return {\n        totalMembers: users.totalItems,\n        activeMembers: activeUsers.totalItems,\n        pendingMembers: pendingUsers.totalItems,\n        totalMemberships: activeMemberships.totalItems,\n        expiringMemberships: expiringMemberships.totalItems\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pb);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcG9ja2V0YmFzZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUdwQyw4QkFBOEI7QUFDOUIsTUFBTUM7SUFHSixPQUFjQyxjQUEwQjtRQUN0QyxJQUFJLENBQUNELGlCQUFpQkUsUUFBUSxFQUFFO1lBQzlCLE1BQU1DLE1BQU1DLDBCQUFzQyxJQUFJLENBQXVCO1lBQzdFSixpQkFBaUJFLFFBQVEsR0FBRyxJQUFJSCxrREFBVUEsQ0FBQ0k7UUFDN0M7UUFDQSxPQUFPSCxpQkFBaUJFLFFBQVE7SUFDbEM7QUFDRjtBQUVPLE1BQU1LLEtBQUtQLGlCQUFpQkMsV0FBVyxHQUFHO0FBRWpELCtDQUErQztBQUN4QyxNQUFNTztJQUNYLGFBQWFDLDJCQUEyQkMsU0FBaUIsRUFBZ0M7UUFDdkYsSUFBSTtZQUNGLE1BQU1DLFNBQVMsTUFBTUosR0FBR0ssVUFBVSxDQUFDLGlCQUFpQkMsZ0JBQWdCLENBQ2xFLGdCQUEwQixPQUFWSCxXQUFVO1lBRTVCLE9BQU9DO1FBQ1QsRUFBRSxPQUFPRyxPQUFPO1lBQ2RDLFFBQVFDLElBQUksQ0FBQyxpQkFBMkIsT0FBVk4sV0FBVSw4Q0FBNENJO1lBQ3BGLE9BQU87UUFDVDtJQUNGO0lBRUEsYUFBYUcsbUJBQWlEO1FBQzVELElBQUksS0FBNkIsRUFBRSxFQUFZO1FBRS9DLE1BQU1DLFdBQVdDLE9BQU9DLFFBQVEsQ0FBQ0YsUUFBUTtRQUN6QyxNQUFNUixZQUFZUSxTQUFTRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFFeEMsa0VBQWtFO1FBQ2xFLElBQUlILGFBQWEsZUFBZUEsU0FBU0ksUUFBUSxDQUFDLGNBQWM7WUFDOUQsTUFBTUMsWUFBWSxJQUFJQyxnQkFBZ0JMLE9BQU9DLFFBQVEsQ0FBQ0ssTUFBTTtZQUM1RCxNQUFNQyxjQUFjSCxVQUFVSSxHQUFHLENBQUM7WUFDbEMsSUFBSUQsYUFBYTtnQkFDZixPQUFPLElBQUksQ0FB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QUFRLGdCQUF5QixPQUFUVyxVQUFTO0lBQ25DO0lBRUEsTUFBTXlELGVBQWUsTUFBTTNGLEdBQUdLLFVBQVUsQ0FBQyxTQUFTaUIsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUM5REMsUUFBUSxnQkFBeUIsT0FBVFcsVUFBUztJQUNuQztJQUVBLE1BQU0wRCxvQkFBb0IsTUFBTTVGLEdBQUdLLFVBQVUsQ0FBQyxlQUFlaUIsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUN6RUMsUUFBUSxnQkFBeUIsT0FBVFcsVUFBUztJQUNuQztJQUVBLGdEQUFnRDtJQUNoRCxNQUFNMkQsb0JBQW9CLElBQUkvRDtJQUM5QitELGtCQUFrQkMsT0FBTyxDQUFDRCxrQkFBa0JFLE9BQU8sS0FBSztJQUN4RCxNQUFNQyxzQkFBc0IsTUFBTWhHLEdBQUdLLFVBQVUsQ0FBQyxlQUFlaUIsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUMzRUMsUUFBUSxnQkFBa0VzRSxPQUFsRDNELFVBQVMsMkNBQXVGLE9BQTlDMkQsa0JBQWtCOUQsV0FBVyxHQUFHakIsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUM7SUFDMUg7SUFFQSxPQUFPO1FBQ0xtRixjQUFjWCxNQUFNWSxVQUFVO1FBQzlCQyxlQUFlVCxZQUFZUSxVQUFVO1FBQ3JDRSxnQkFBZ0JULGFBQWFPLFVBQVU7UUFDdkNHLGtCQUFrQlQsa0JBQWtCTSxVQUFVO1FBQzlDRixxQkFBcUJBLG9CQUFvQkUsVUFBVTtJQUNyRDtBQUNGLEVBQUU7QUFFRixpRUFBZWxHLEVBQUVBLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvc3JjL2xpYi9wb2NrZXRiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQb2NrZXRCYXNlIGZyb20gJ3BvY2tldGJhc2UnO1xuaW1wb3J0IHR5cGUgeyBPcmdhbml6YXRpb24sIFVzZXIsIE1lbWJlcnNoaXBUeXBlLCBNZW1iZXJzaGlwLCBNYWlsaW5nTGlzdCwgTGlzdFN1YnNjcmlwdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBQb2NrZXRCYXNlIGNsaWVudCBzaW5nbGV0b25cbmNsYXNzIFBvY2tldEJhc2VDbGllbnQge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUG9ja2V0QmFzZTtcblxuICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IFBvY2tldEJhc2Uge1xuICAgIGlmICghUG9ja2V0QmFzZUNsaWVudC5pbnN0YW5jZSkge1xuICAgICAgY29uc3QgdXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUE9DS0VUQkFTRV9VUkwgfHwgJ2h0dHA6Ly8xMjcuMC4wLjE6ODA5MCc7XG4gICAgICBQb2NrZXRCYXNlQ2xpZW50Lmluc3RhbmNlID0gbmV3IFBvY2tldEJhc2UodXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIFBvY2tldEJhc2VDbGllbnQuaW5zdGFuY2U7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHBiID0gUG9ja2V0QmFzZUNsaWVudC5nZXRJbnN0YW5jZSgpO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBtdWx0aS10ZW5hbnQgb3BlcmF0aW9uc1xuZXhwb3J0IGNsYXNzIFRlbmFudFNlcnZpY2Uge1xuICBzdGF0aWMgYXN5bmMgZ2V0T3JnYW5pemF0aW9uQnlTdWJkb21haW4oc3ViZG9tYWluOiBzdHJpbmcpOiBQcm9taXNlPE9yZ2FuaXphdGlvbiB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVjb3JkID0gYXdhaXQgcGIuY29sbGVjdGlvbignb3JnYW5pemF0aW9ucycpLmdldEZpcnN0TGlzdEl0ZW0oXG4gICAgICAgIGBzdWJkb21haW4gPSBcIiR7c3ViZG9tYWlufVwiICYmIHN0YXR1cyA9IFwiYWN0aXZlXCJgXG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlY29yZCBhcyBPcmdhbml6YXRpb247XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgT3JnYW5pemF0aW9uICcke3N1YmRvbWFpbn0nIG5vdCBmb3VuZCBvciBQb2NrZXRCYXNlIG5vdCBhY2Nlc3NpYmxlOmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBnZXRDdXJyZW50VGVuYW50KCk6IFByb21pc2U8T3JnYW5pemF0aW9uIHwgbnVsbD4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgY29uc3QgaG9zdG5hbWUgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgY29uc3Qgc3ViZG9tYWluID0gaG9zdG5hbWUuc3BsaXQoJy4nKVswXTtcbiAgICBcbiAgICAvLyBGb3IgZGV2ZWxvcG1lbnQsIGNoZWNrIGlmIHN1YmRvbWFpbiBpcyBpbiB0aGUgVVJMIHBhdGggb3IgcXVlcnlcbiAgICBpZiAoaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8IGhvc3RuYW1lLmluY2x1ZGVzKCcxMjcuMC4wLjEnKSkge1xuICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgIGNvbnN0IHRlbmFudFBhcmFtID0gdXJsUGFyYW1zLmdldCgndGVuYW50Jyk7XG4gICAgICBpZiAodGVuYW50UGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JnYW5pemF0aW9uQnlTdWJkb21haW4odGVuYW50UGFyYW0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUcnkgdG8gZ2V0IGRlZmF1bHQgb3JnYW5pemF0aW9uIGZvciBkZXZlbG9wbWVudFxuICAgICAgLy8gVHJ5IHRvIGdldCBkZWZhdWx0IG9yZ2FuaXphdGlvbiBmb3IgZGV2ZWxvcG1lbnRcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlY29yZHMgPSBhd2FpdCBwYi5jb2xsZWN0aW9uKCdvcmdhbml6YXRpb25zJykuZ2V0TGlzdCgxLCAxLCB7XG4gICAgICAgICAgZmlsdGVyOiAnc3RhdHVzID0gXCJhY3RpdmVcIidcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZWNvcmRzLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gcmVjb3Jkcy5pdGVtc1swXSBhcyBPcmdhbml6YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIElmIG5vIG9yZ2FuaXphdGlvbnMgZXhpc3QsIHJldHVybiBhIGRldmVsb3BtZW50IGZhbGxiYWNrXG4gICAgICAgIGNvbnNvbGUud2FybignTm8gb3JnYW5pemF0aW9ucyBmb3VuZCBpbiBkYXRhYmFzZS4gVXNpbmcgZGV2ZWxvcG1lbnQgZmFsbGJhY2suJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6ICdkZXYtb3JnJyxcbiAgICAgICAgICBuYW1lOiAnRGV2ZWxvcG1lbnQgT3JnYW5pemF0aW9uJyxcbiAgICAgICAgICBzdWJkb21haW46ICdkZXYtb3JnJyxcbiAgICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSBhcyBPcmdhbml6YXRpb247XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1BvY2tldEJhc2Ugbm90IGFjY2Vzc2libGUuIFVzaW5nIGRldmVsb3BtZW50IGZhbGxiYWNrIG9yZ2FuaXphdGlvbi4nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogJ2Rldi1vcmcnLFxuICAgICAgICAgIG5hbWU6ICdEZXZlbG9wbWVudCBPcmdhbml6YXRpb24nLFxuICAgICAgICAgIHN1YmRvbWFpbjogJ2Rldi1vcmcnLFxuICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgICAgY3JlYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9IGFzIE9yZ2FuaXphdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuZ2V0T3JnYW5pemF0aW9uQnlTdWJkb21haW4oc3ViZG9tYWluKTtcbiAgfVxuXG4gIHN0YXRpYyBzZXRUZW5hbnRDb250ZXh0KHRlbmFudElkOiBzdHJpbmcpIHtcbiAgICAvLyBTZXQgdGVuYW50IGNvbnRleHQgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHNcbiAgICBwYi5iZWZvcmVTZW5kID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICdYLVRlbmFudC1JRCc6IHRlbmFudElkLFxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IHVybCwgb3B0aW9ucyB9O1xuICAgIH07XG4gIH1cbn1cblxuLy8gQXV0aGVudGljYXRpb24gaGVscGVyc1xuZXhwb3J0IGNsYXNzIEF1dGhTZXJ2aWNlIHtcbiAgc3RhdGljIGFzeW5jIGxvZ2luKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcsIHRlbmFudElkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgVGVuYW50U2VydmljZS5zZXRUZW5hbnRDb250ZXh0KHRlbmFudElkKTtcbiAgICAgIGNvbnN0IGF1dGhEYXRhID0gYXdhaXQgcGIuY29sbGVjdGlvbigndXNlcnMnKS5hdXRoV2l0aFBhc3N3b3JkKGVtYWlsLCBwYXNzd29yZCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB1c2VyIGJlbG9uZ3MgdG8gdGhlIGNvcnJlY3QgdGVuYW50XG4gICAgICBpZiAoYXV0aERhdGEucmVjb3JkLnRlbmFudF9pZCAhPT0gdGVuYW50SWQpIHtcbiAgICAgICAgYXdhaXQgcGIuYXV0aFN0b3JlLmNsZWFyKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjcmVkZW50aWFscyBmb3IgdGhpcyBvcmdhbml6YXRpb24nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGF1dGhEYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgcmVnaXN0ZXIodXNlckRhdGE6IHtcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIHBhc3N3b3JkOiBzdHJpbmc7XG4gICAgcGFzc3dvcmRDb25maXJtOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHRlbmFudF9pZDogc3RyaW5nO1xuICB9KSB7XG4gICAgdHJ5IHtcbiAgICAgIFRlbmFudFNlcnZpY2Uuc2V0VGVuYW50Q29udGV4dCh1c2VyRGF0YS50ZW5hbnRfaWQpO1xuICAgICAgXG4gICAgICBjb25zdCByZWNvcmQgPSBhd2FpdCBwYi5jb2xsZWN0aW9uKCd1c2VycycpLmNyZWF0ZSh7XG4gICAgICAgIC4uLnVzZXJEYXRhLFxuICAgICAgICByb2xlOiAnbWVtYmVyJyxcbiAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignUmVnaXN0cmF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBsb2dvdXQoKSB7XG4gICAgcGIuYXV0aFN0b3JlLmNsZWFyKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0Q3VycmVudFVzZXIoKTogVXNlciB8IG51bGwge1xuICAgIHJldHVybiBwYi5hdXRoU3RvcmUubW9kZWwgYXMgVXNlciB8IG51bGw7XG4gIH1cblxuICBzdGF0aWMgaXNBdXRoZW50aWNhdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwYi5hdXRoU3RvcmUuaXNWYWxpZDtcbiAgfVxufVxuXG5jb25zdCBnZXRDdXJyZW50VGVuYW50SWQgPSAoKTogc3RyaW5nIHwgbnVsbCA9PiB7XG4gIHJldHVybiBwYi5hdXRoU3RvcmUubW9kZWw/LnRlbmFudF9pZCB8fCBudWxsO1xufTtcblxuLy8gT3JnYW5pemF0aW9uIG1ldGhvZHNcbmV4cG9ydCBjb25zdCBnZXRPcmdhbml6YXRpb24gPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8T3JnYW5pemF0aW9uIHwgbnVsbD4gPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBwYi5jb2xsZWN0aW9uKCdvcmdhbml6YXRpb25zJykuZ2V0T25lKGlkKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBvcmdhbml6YXRpb246JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0T3JnYW5pemF0aW9uQnlTdWJkb21haW4gPSBhc3luYyAoc3ViZG9tYWluOiBzdHJpbmcpOiBQcm9taXNlPE9yZ2FuaXphdGlvbiB8IG51bGw+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZWNvcmRzID0gYXdhaXQgcGIuY29sbGVjdGlvbignb3JnYW5pemF0aW9ucycpLmdldExpc3QoMSwgMSwge1xuICAgICAgZmlsdGVyOiBgc3ViZG9tYWluID0gXCIke3N1YmRvbWFpbn1cImBcbiAgICB9KTtcbiAgICByZXR1cm4gcmVjb3Jkcy5pdGVtc1swXSB8fCBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG9yZ2FuaXphdGlvbiBieSBzdWJkb21haW46JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vLyBVc2VyIG1ldGhvZHNcbmV4cG9ydCBjb25zdCBnZXRVc2VycyA9IGFzeW5jIChwYWdlID0gMSwgcGVyUGFnZSA9IDUwLCBmaWx0ZXIgPSAnJykgPT4ge1xuICByZXR1cm4gYXdhaXQgcGIuY29sbGVjdGlvbigndXNlcnMnKS5nZXRMaXN0KHBhZ2UsIHBlclBhZ2UsIHtcbiAgICBmaWx0ZXI6IGZpbHRlciA/IGBuYW1lIH4gXCIke2ZpbHRlcn1cIiB8fCBlbWFpbCB+IFwiJHtmaWx0ZXJ9XCJgIDogJycsXG4gICAgc29ydDogJy1jcmVhdGVkJyxcbiAgICBleHBhbmQ6ICd0ZW5hbnRfaWQnXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVVzZXJTdGF0dXMgPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBhd2FpdCBwYi5jb2xsZWN0aW9uKCd1c2VycycpLnVwZGF0ZSh1c2VySWQsIHsgc3RhdHVzIH0pO1xufTtcblxuLy8gTWVtYmVyc2hpcCBUeXBlIG1ldGhvZHNcbmV4cG9ydCBjb25zdCBnZXRNZW1iZXJzaGlwVHlwZXMgPSBhc3luYyAoKSA9PiB7XG4gIHJldHVybiBhd2FpdCBwYi5jb2xsZWN0aW9uKCdtZW1iZXJzaGlwX3R5cGVzJykuZ2V0RnVsbExpc3Qoe1xuICAgIGZpbHRlcjogJ2FjdGl2ZSA9IHRydWUnLFxuICAgIHNvcnQ6ICdwcmljZSdcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTWVtYmVyc2hpcFR5cGUgPSBhc3luYyAoZGF0YTogUGFydGlhbDxNZW1iZXJzaGlwVHlwZT4pID0+IHtcbiAgcmV0dXJuIGF3YWl0IHBiLmNvbGxlY3Rpb24oJ21lbWJlcnNoaXBfdHlwZXMnKS5jcmVhdGUoe1xuICAgIC4uLmRhdGEsXG4gICAgdGVuYW50X2lkOiBnZXRDdXJyZW50VGVuYW50SWQoKVxuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVNZW1iZXJzaGlwVHlwZSA9IGFzeW5jIChpZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPE1lbWJlcnNoaXBUeXBlPikgPT4ge1xuICByZXR1cm4gYXdhaXQgcGIuY29sbGVjdGlvbignbWVtYmVyc2hpcF90eXBlcycpLnVwZGF0ZShpZCwgZGF0YSk7XG59O1xuXG4vLyBNZW1iZXJzaGlwIG1ldGhvZHNcbmV4cG9ydCBjb25zdCBnZXRNZW1iZXJzaGlwcyA9IGFzeW5jIChwYWdlID0gMSwgcGVyUGFnZSA9IDUwLCBmaWx0ZXIgPSAnJykgPT4ge1xuICByZXR1cm4gYXdhaXQgcGIuY29sbGVjdGlvbignbWVtYmVyc2hpcHMnKS5nZXRMaXN0KHBhZ2UsIHBlclBhZ2UsIHtcbiAgICBmaWx0ZXIsXG4gICAgc29ydDogJy1jcmVhdGVkJyxcbiAgICBleHBhbmQ6ICd1c2VyX2lkLG1lbWJlcnNoaXBfdHlwZV9pZCdcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTWVtYmVyc2hpcCA9IGFzeW5jIChkYXRhOiBQYXJ0aWFsPE1lbWJlcnNoaXA+KSA9PiB7XG4gIHJldHVybiBhd2FpdCBwYi5jb2xsZWN0aW9uKCdtZW1iZXJzaGlwcycpLmNyZWF0ZSh7XG4gICAgLi4uZGF0YSxcbiAgICB0ZW5hbnRfaWQ6IGdldEN1cnJlbnRUZW5hbnRJZCgpXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZU1lbWJlcnNoaXAgPSBhc3luYyAoaWQ6IHN0cmluZywgZGF0YTogUGFydGlhbDxNZW1iZXJzaGlwPikgPT4ge1xuICByZXR1cm4gYXdhaXQgcGIuY29sbGVjdGlvbignbWVtYmVyc2hpcHMnKS51cGRhdGUoaWQsIGRhdGEpO1xufTtcblxuLy8gTWFpbGluZyBMaXN0IG1ldGhvZHNcbmV4cG9ydCBjb25zdCBnZXRNYWlsaW5nTGlzdHMgPSBhc3luYyAoKSA9PiB7XG4gIHJldHVybiBhd2FpdCBwYi5jb2xsZWN0aW9uKCdtYWlsaW5nX2xpc3RzJykuZ2V0RnVsbExpc3Qoe1xuICAgIGZpbHRlcjogJ2FjdGl2ZSA9IHRydWUnLFxuICAgIHNvcnQ6ICduYW1lJ1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYWlsaW5nTGlzdCA9IGFzeW5jIChkYXRhOiBQYXJ0aWFsPE1haWxpbmdMaXN0PikgPT4ge1xuICByZXR1cm4gYXdhaXQgcGIuY29sbGVjdGlvbignbWFpbGluZ19saXN0cycpLmNyZWF0ZSh7XG4gICAgLi4uZGF0YSxcbiAgICB0ZW5hbnRfaWQ6IGdldEN1cnJlbnRUZW5hbnRJZCgpXG4gIH0pO1xufTtcblxuLy8gTGlzdCBTdWJzY3JpcHRpb24gbWV0aG9kc1xuZXhwb3J0IGNvbnN0IGdldFVzZXJTdWJzY3JpcHRpb25zID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBhd2FpdCBwYi5jb2xsZWN0aW9uKCdsaXN0X3N1YnNjcmlwdGlvbnMnKS5nZXRGdWxsTGlzdCh7XG4gICAgZmlsdGVyOiBgdXNlcl9pZCA9IFwiJHt1c2VySWR9XCJgLFxuICAgIGV4cGFuZDogJ2xpc3RfaWQnXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVN1YnNjcmlwdGlvbiA9IGFzeW5jICh1c2VySWQ6IHN0cmluZywgbGlzdElkOiBzdHJpbmcsIHN1YnNjcmliZWQ6IGJvb2xlYW4pID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBUcnkgdG8gZmluZCBleGlzdGluZyBzdWJzY3JpcHRpb25cbiAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IHBiLmNvbGxlY3Rpb24oJ2xpc3Rfc3Vic2NyaXB0aW9ucycpLmdldEZpcnN0TGlzdEl0ZW0oYHVzZXJfaWQgPSBcIiR7dXNlcklkfVwiICYmIGxpc3RfaWQgPSBcIiR7bGlzdElkfVwiYCk7XG4gICAgcmV0dXJuIGF3YWl0IHBiLmNvbGxlY3Rpb24oJ2xpc3Rfc3Vic2NyaXB0aW9ucycpLnVwZGF0ZShleGlzdGluZy5pZCwgeyBzdWJzY3JpYmVkIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIENyZWF0ZSBuZXcgc3Vic2NyaXB0aW9uIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICByZXR1cm4gYXdhaXQgcGIuY29sbGVjdGlvbignbGlzdF9zdWJzY3JpcHRpb25zJykuY3JlYXRlKHtcbiAgICAgIHRlbmFudF9pZDogZ2V0Q3VycmVudFRlbmFudElkKCksXG4gICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICBsaXN0X2lkOiBsaXN0SWQsXG4gICAgICBzdWJzY3JpYmVkXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIERhc2hib2FyZCBzdGF0c1xuZXhwb3J0IGNvbnN0IGdldERhc2hib2FyZFN0YXRzID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB0ZW5hbnRJZCA9IGdldEN1cnJlbnRUZW5hbnRJZCgpO1xuICBpZiAoIXRlbmFudElkKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHRlbmFudCBjb250ZXh0Jyk7XG5cbiAgY29uc3QgW3VzZXJzLCBtZW1iZXJzaGlwc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgcGIuY29sbGVjdGlvbigndXNlcnMnKS5nZXRMaXN0KDEsIDEsIHsgZmlsdGVyOiBgdGVuYW50X2lkID0gXCIke3RlbmFudElkfVwiYCB9KSxcbiAgICBwYi5jb2xsZWN0aW9uKCdtZW1iZXJzaGlwcycpLmdldExpc3QoMSwgMSwgeyBmaWx0ZXI6IGB0ZW5hbnRfaWQgPSBcIiR7dGVuYW50SWR9XCJgIH0pXG4gIF0pO1xuXG4gIGNvbnN0IGFjdGl2ZVVzZXJzID0gYXdhaXQgcGIuY29sbGVjdGlvbigndXNlcnMnKS5nZXRMaXN0KDEsIDEsIHtcbiAgICBmaWx0ZXI6IGB0ZW5hbnRfaWQgPSBcIiR7dGVuYW50SWR9XCIgJiYgc3RhdHVzID0gXCJhY3RpdmVcImBcbiAgfSk7XG5cbiAgY29uc3QgcGVuZGluZ1VzZXJzID0gYXdhaXQgcGIuY29sbGVjdGlvbigndXNlcnMnKS5nZXRMaXN0KDEsIDEsIHtcbiAgICBmaWx0ZXI6IGB0ZW5hbnRfaWQgPSBcIiR7dGVuYW50SWR9XCIgJiYgc3RhdHVzID0gXCJwZW5kaW5nXCJgXG4gIH0pO1xuXG4gIGNvbnN0IGFjdGl2ZU1lbWJlcnNoaXBzID0gYXdhaXQgcGIuY29sbGVjdGlvbignbWVtYmVyc2hpcHMnKS5nZXRMaXN0KDEsIDEsIHtcbiAgICBmaWx0ZXI6IGB0ZW5hbnRfaWQgPSBcIiR7dGVuYW50SWR9XCIgJiYgc3RhdHVzID0gXCJhY3RpdmVcImBcbiAgfSk7XG5cbiAgLy8gQ2FsY3VsYXRlIGV4cGlyaW5nIG1lbWJlcnNoaXBzIChuZXh0IDMwIGRheXMpXG4gIGNvbnN0IHRoaXJ0eURheXNGcm9tTm93ID0gbmV3IERhdGUoKTtcbiAgdGhpcnR5RGF5c0Zyb21Ob3cuc2V0RGF0ZSh0aGlydHlEYXlzRnJvbU5vdy5nZXREYXRlKCkgKyAzMCk7XG4gIGNvbnN0IGV4cGlyaW5nTWVtYmVyc2hpcHMgPSBhd2FpdCBwYi5jb2xsZWN0aW9uKCdtZW1iZXJzaGlwcycpLmdldExpc3QoMSwgMSwge1xuICAgIGZpbHRlcjogYHRlbmFudF9pZCA9IFwiJHt0ZW5hbnRJZH1cIiAmJiBzdGF0dXMgPSBcImFjdGl2ZVwiICYmIGVuZF9kYXRlIDw9IFwiJHt0aGlydHlEYXlzRnJvbU5vdy50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF19XCJgXG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgdG90YWxNZW1iZXJzOiB1c2Vycy50b3RhbEl0ZW1zLFxuICAgIGFjdGl2ZU1lbWJlcnM6IGFjdGl2ZVVzZXJzLnRvdGFsSXRlbXMsXG4gICAgcGVuZGluZ01lbWJlcnM6IHBlbmRpbmdVc2Vycy50b3RhbEl0ZW1zLFxuICAgIHRvdGFsTWVtYmVyc2hpcHM6IGFjdGl2ZU1lbWJlcnNoaXBzLnRvdGFsSXRlbXMsXG4gICAgZXhwaXJpbmdNZW1iZXJzaGlwczogZXhwaXJpbmdNZW1iZXJzaGlwcy50b3RhbEl0ZW1zXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYjsiXSwibmFtZXMiOlsiUG9ja2V0QmFzZSIsIlBvY2tldEJhc2VDbGllbnQiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwidXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1BPQ0tFVEJBU0VfVVJMIiwicGIiLCJUZW5hbnRTZXJ2aWNlIiwiZ2V0T3JnYW5pemF0aW9uQnlTdWJkb21haW4iLCJzdWJkb21haW4iLCJyZWNvcmQiLCJjb2xsZWN0aW9uIiwiZ2V0Rmlyc3RMaXN0SXRlbSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJnZXRDdXJyZW50VGVuYW50IiwiaG9zdG5hbWUiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInNwbGl0IiwiaW5jbHVkZXMiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJ0ZW5hbnRQYXJhbSIsImdldCIsInJlY29yZHMiLCJnZXRMaXN0IiwiZmlsdGVyIiwiaXRlbXMiLCJsZW5ndGgiLCJpZCIsIm5hbWUiLCJzdGF0dXMiLCJjcmVhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlZCIsInNldFRlbmFudENvbnRleHQiLCJ0ZW5hbnRJZCIsImJlZm9yZVNlbmQiLCJvcHRpb25zIiwiaGVhZGVycyIsIkF1dGhTZXJ2aWNlIiwibG9naW4iLCJlbWFpbCIsInBhc3N3b3JkIiwiYXV0aERhdGEiLCJhdXRoV2l0aFBhc3N3b3JkIiwidGVuYW50X2lkIiwiYXV0aFN0b3JlIiwiY2xlYXIiLCJFcnJvciIsInJlZ2lzdGVyIiwidXNlckRhdGEiLCJjcmVhdGUiLCJyb2xlIiwibG9nb3V0IiwiZ2V0Q3VycmVudFVzZXIiLCJtb2RlbCIsImlzQXV0aGVudGljYXRlZCIsImlzVmFsaWQiLCJnZXRDdXJyZW50VGVuYW50SWQiLCJnZXRPcmdhbml6YXRpb24iLCJnZXRPbmUiLCJnZXRVc2VycyIsInBhZ2UiLCJwZXJQYWdlIiwic29ydCIsImV4cGFuZCIsInVwZGF0ZVVzZXJTdGF0dXMiLCJ1c2VySWQiLCJ1cGRhdGUiLCJnZXRNZW1iZXJzaGlwVHlwZXMiLCJnZXRGdWxsTGlzdCIsImNyZWF0ZU1lbWJlcnNoaXBUeXBlIiwiZGF0YSIsInVwZGF0ZU1lbWJlcnNoaXBUeXBlIiwiZ2V0TWVtYmVyc2hpcHMiLCJjcmVhdGVNZW1iZXJzaGlwIiwidXBkYXRlTWVtYmVyc2hpcCIsImdldE1haWxpbmdMaXN0cyIsImNyZWF0ZU1haWxpbmdMaXN0IiwiZ2V0VXNlclN1YnNjcmlwdGlvbnMiLCJ1cGRhdGVTdWJzY3JpcHRpb24iLCJsaXN0SWQiLCJzdWJzY3JpYmVkIiwiZXhpc3RpbmciLCJ1c2VyX2lkIiwibGlzdF9pZCIsImdldERhc2hib2FyZFN0YXRzIiwidXNlcnMiLCJtZW1iZXJzaGlwcyIsIlByb21pc2UiLCJhbGwiLCJhY3RpdmVVc2VycyIsInBlbmRpbmdVc2VycyIsImFjdGl2ZU1lbWJlcnNoaXBzIiwidGhpcnR5RGF5c0Zyb21Ob3ciLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImV4cGlyaW5nTWVtYmVyc2hpcHMiLCJ0b3RhbE1lbWJlcnMiLCJ0b3RhbEl0ZW1zIiwiYWN0aXZlTWVtYmVycyIsInBlbmRpbmdNZW1iZXJzIiwidG90YWxNZW1iZXJzaGlwcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/pocketbase.ts\n"));

/***/ })

});